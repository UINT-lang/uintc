%{
#include "parser.hpp"
#include <bits/stdc++.h>
using namespace std;
using namespace UINTC;
namespace UINTC {
    int currentLineNumber = 1;
    string globalResult;
    string parseInlineStringLiteral(const string& s) {
        assert(s.size() >= 2);
        assert(s.front() == '"');
        assert(s.back() == '"');
        return s.substr(1, s.size() - 2);
    }
    string parseMultilineStringLiteral(const string& s) {
        assert(s.size() >= 7);
        assert(s.substr(0, 4) == "\"\"\"\n");
        assert(s.substr(s.size() - 3, 3) == "\"\"\"");
        return s.substr(4, s.size() - 7);
    }
    int32_t parseInt32(const string& s) {
        int32_t ret = stoi(s.substr(0, s.size() - 3));
        if (s != to_string(ret) + "i32") {
            cerr << "Invalid i32 literal: " << s << endl;
            exit(1);
        }
        return ret;
    }
}
%}

%option reentrant interactive noyywrap nodefault

inline_string_literal    (["]([^"])*["])
multiline_string_literal (\"\"\"\n([^"]|\"[^"]|\"\"[^"])*\"\"\")

identifier       ([a-zA-Z_][a-zA-Z0-9_]*)(\?|!)?

char_literal     ('[ -~]')
i32_literal      ([0-9]+)i32
f64_literal      ([0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?)f64

%%
 
"("     return Parser::token::LPAREN;
")"     return Parser::token::RPAREN;
";"     return Parser::token::SEMICOLON;
"{"     return Parser::token::LBRACE;
"}"     return Parser::token::RBRACE;
"="     return Parser::token::EQUAL;
"=="    return Parser::token::EQUALS;
"<<"    return Parser::token::LEFT_SHIFT;
"+"     return Parser::token::PLUS;
"-"     return Parser::token::MINUS;
"."     return Parser::token::DOT;
"<"     return Parser::token::LESS_THAN;
">"     return Parser::token::GREATER_THAN;
":"     return Parser::token::COLON;
"?"     return Parser::token::QUESTION_MARK;
"*"     return Parser::token::STAR;
","     return Parser::token::COMMA;
"/"     return Parser::token::SLASH;
"+="    return Parser::token::PLUS_EQUAL;
"%"     return Parser::token::MOD;
"&&"    return Parser::token::LOGICAL_AND;
">="    return Parser::token::GREATER_EQUAL;
"<="    return Parser::token::LESS_EQUAL;
"["     return Parser::token::LBRACKET;
"]"     return Parser::token::RBRACKET;
"|"     return Parser::token::PIPE;
"=>"    return Parser::token::DOUBLE_ARROW;

"'\\n'" return Parser::token::CHAR_LITERAL_NEWLINE;

" "     ;
\n      UINTC::currentLineNumber++;

"cpp"   return Parser::token::CPP;
"fn"    return Parser::token::FN;
"let"   return Parser::token::LET;
"let!"  return Parser::token::LET_MUT;
"for"   return Parser::token::FOR;
"ref"   return Parser::token::REF;
"while" return Parser::token::WHILE;
"if"    return Parser::token::IF;
"else"  return Parser::token::ELSE;

{inline_string_literal}    yylval->emplace<string>(parseInlineStringLiteral(yytext)); return Parser::token::INLINE_STRING_LITERAL;
{multiline_string_literal} yylval->emplace<string>(parseMultilineStringLiteral(yytext)); UINTC::currentLineNumber += count(yytext, yytext + strlen(yytext), '\n'); return Parser::token::MULTILINE_STRING_LITERAL;
{identifier}       yylval->emplace<string>(yytext); return Parser::token::IDENTIFIER;
{i32_literal}      yylval->emplace<int32_t>(UINTC::parseInt32(yytext)); return Parser::token::I32_LITERAL;
{f64_literal}      yylval->emplace<double>(stod(yytext)); return Parser::token::F64_LITERAL;
{char_literal}     yylval->emplace<char>(yytext[1]); return Parser::token::CHAR_LITERAL;

<<EOF>>     return Parser::token::YYEOF;
.           { cerr << "Unrecognized token: " << yytext << endl; exit(1); }

%%

#include "begin.hpp.inc"
#include "end.hpp.inc"
#include "begin.uint.inc"
#include "end.uint.inc"

int main() {
    const string begin_hpp(template_begin_hpp, template_begin_hpp + template_begin_hpp_len);
    const string end_hpp(template_end_hpp, template_end_hpp + template_end_hpp_len);
    const string begin_uint(template_begin_uint, template_begin_uint + template_begin_uint_len);
    const string end_uint(template_end_uint, template_end_uint + template_end_uint_len);

    string allInput = begin_uint;
    char c;
    while (cin.get(c))
        allInput += c;
    allInput += end_uint;
    
    yyscan_t scanner;
    yylex_init(&scanner);
    yy_scan_string(allInput.c_str(), scanner);
    UINTC::Parser parser { scanner };
    int r = parser.parse();
    yylex_destroy(scanner);
    if (r)
        return 1;

    cout
        << "/* This file was generated by the UINT compiler with the following input:\n\n"
        << allInput
        << "\n*/\n\n"
        << begin_hpp
        << globalResult
        << end_hpp;
}
