%{
#include "parser.hpp"
#include <bits/stdc++.h>
using namespace std;
using namespace UINTC;
namespace UINTC {
    int currentLineNumber = 1;
    string globalResult;
    string parseInlineStringLiteral(const string& s) {
        assert(s.size() >= 2);
        assert(s.front() == '"');
        assert(s.back() == '"');
        return s.substr(1, s.size() - 2);
    }
    string parseMultilineStringLiteral(const string& s) {
        assert(s.size() >= 7);
        assert(s.substr(0, 4) == "\"\"\"\n");
        assert(s.substr(s.size() - 3, 3) == "\"\"\"");
        return s.substr(4, s.size() - 7);
    }
    int32_t parseInt32(const string& s) {
        int32_t ret = stoi(s.substr(0, s.size() - 3));
        if (s != to_string(ret) + "i32") {
            cerr << "Invalid i32 literal: " << s << endl;
            exit(1);
        }
        return ret;
    }
}
%}

%option reentrant interactive noyywrap nodefault

inline_string_literal    (["]([^"])*["])
multiline_string_literal (\"\"\"\n([^"]|\"[^"]|\"\"[^"])*\"\"\")

identifier       ([a-zA-Z_][a-zA-Z0-9_]*)(\?|!)?

char_literal     ('[ -~]')
i32_literal      ([0-9]+)i32
f64_literal      ([0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?)f64

%%
 
"("     return Parser::token::LPAREN;
")"     return Parser::token::RPAREN;
";"     return Parser::token::SEMICOLON;
"{"     return Parser::token::LBRACE;
"}"     return Parser::token::RBRACE;
"="     return Parser::token::EQUAL;
"=="    return Parser::token::EQUALS;
"<<"    return Parser::token::LEFT_SHIFT;
"+"     return Parser::token::PLUS;
"-"     return Parser::token::MINUS;
"."     return Parser::token::DOT;
"<"     return Parser::token::LESS_THAN;
">"     return Parser::token::GREATER_THAN;
":"     return Parser::token::COLON;
"?"     return Parser::token::QUESTION_MARK;
"*"     return Parser::token::STAR;
","     return Parser::token::COMMA;
"/"     return Parser::token::SLASH;
"+="    return Parser::token::PLUS_EQUAL;
"%"     return Parser::token::MOD;
"&&"    return Parser::token::LOGICAL_AND;
">="    return Parser::token::GREATER_EQUAL;
"<="    return Parser::token::LESS_EQUAL;

"'\\n'" return Parser::token::CHAR_LITERAL_NEWLINE;

" "     ;
\n      UINTC::currentLineNumber++;

"cpp"   return Parser::token::CPP;
"fn"    return Parser::token::FN;
"let"   return Parser::token::LET;
"let!"  return Parser::token::LET_MUT;
"for"   return Parser::token::FOR;
"ref"   return Parser::token::REF;
"while" return Parser::token::WHILE;

{inline_string_literal}    yylval->emplace<string>(parseInlineStringLiteral(yytext)); return Parser::token::INLINE_STRING_LITERAL;
{multiline_string_literal} yylval->emplace<string>(parseMultilineStringLiteral(yytext)); UINTC::currentLineNumber += count(yytext, yytext + strlen(yytext), '\n'); return Parser::token::MULTILINE_STRING_LITERAL;
{identifier}       yylval->emplace<string>(yytext); return Parser::token::IDENTIFIER;
{i32_literal}      yylval->emplace<int32_t>(UINTC::parseInt32(yytext)); return Parser::token::I32_LITERAL;
{f64_literal}      yylval->emplace<double>(stod(yytext)); return Parser::token::F64_LITERAL;
{char_literal}     yylval->emplace<char>(yytext[1]); return Parser::token::CHAR_LITERAL;

<<EOF>>     return Parser::token::YYEOF;
.           { cerr << "Unrecognized token: " << yytext << endl; exit(1); }

%%

int main(int argc, char** argv) {
    if (argc != 2) {
        cerr << "Usage: " << argv[0] << " <filename>" << endl;
        return 1;
    }
    yyscan_t scanner;
    yylex_init(&scanner);
    yyset_in(fopen(argv[1], "r"), scanner);
    UINTC::Parser parser { scanner };
    int r = parser.parse();
    yylex_destroy(scanner);
    if (r)
        return 1;
    cout << "/* This file was generated by the UINT compiler with the following input:\n\n";
    auto outputAll = [&] (const char* fileName) {
        ifstream file(fileName);
        string line;
        while (getline(file, line))
            cout << line << '\n';
    };
    outputAll(argv[1]);
    cout << "\n*/\n\n";
    outputAll("cpp_template/begin.hpp");
    cout << globalResult;
    outputAll("cpp_template/end.hpp");
}
